/*
 * Decompiled with CFR 0.152.
 * 
 * Could not load the following classes:
 *  it.unimi.dsi.fastutil.ints.Int2ObjectArrayMap
 *  it.unimi.dsi.fastutil.ints.Int2ObjectMap
 *  net.minecraft.item.ItemStack
 *  net.minecraft.network.packet.Packet
 *  net.minecraft.network.packet.c2s.play.ClickSlotC2SPacket
 *  net.minecraft.network.packet.c2s.play.UpdateSelectedSlotC2SPacket
 *  net.minecraft.network.packet.s2c.play.InventoryS2CPacket
 *  net.minecraft.network.packet.s2c.play.ScreenHandlerSlotUpdateS2CPacket
 *  net.minecraft.network.packet.s2c.play.UpdateSelectedSlotS2CPacket
 *  net.minecraft.screen.slot.Slot
 *  net.minecraft.screen.slot.SlotActionType
 */
package dev.idhammai.mod.modules.impl.exploit;

import dev.idhammai.Frog;
import dev.idhammai.api.events.eventbus.EventListener;
import dev.idhammai.api.events.impl.InventoryS2CPacketEvent;
import dev.idhammai.api.events.impl.LerpToEvent;
import dev.idhammai.api.events.impl.PacketEvent;
import dev.idhammai.api.events.impl.S2CCloseScreenEvent;
import dev.idhammai.api.events.impl.ServerConnectBeginEvent;
import dev.idhammai.api.events.impl.TickEvent;
import dev.idhammai.api.utils.math.Timer;
import dev.idhammai.api.utils.player.EntityUtil;
import dev.idhammai.mod.modules.Module;
import dev.idhammai.mod.modules.impl.player.Sorter;
import dev.idhammai.mod.modules.settings.impl.BooleanSetting;
import dev.idhammai.mod.modules.settings.impl.SliderSetting;
import it.unimi.dsi.fastutil.ints.Int2ObjectArrayMap;
import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
import java.util.List;
import net.minecraft.item.ItemStack;
import net.minecraft.network.packet.Packet;
import net.minecraft.network.packet.c2s.play.ClickSlotC2SPacket;
import net.minecraft.network.packet.c2s.play.UpdateSelectedSlotC2SPacket;
import net.minecraft.network.packet.s2c.play.InventoryS2CPacket;
import net.minecraft.network.packet.s2c.play.ScreenHandlerSlotUpdateS2CPacket;
import net.minecraft.network.packet.s2c.play.UpdateSelectedSlotS2CPacket;
import net.minecraft.screen.slot.Slot;
import net.minecraft.screen.slot.SlotActionType;

public class AntiPacket
extends Module {
    public static AntiPacket INSTANCE;
    public final BooleanSetting decode = this.add(new BooleanSetting("Decode", true));
    public final BooleanSetting lerp = this.add(new BooleanSetting("Lerp", false));
    public final BooleanSetting s2CSlot = this.add(new BooleanSetting("S2CSlot", true));
    public final BooleanSetting s2CRotate = this.add(new BooleanSetting("S2CRotate", true).setParent());
    public final BooleanSetting applyYaw = this.add(new BooleanSetting("ApplyYaw", true, this.s2CRotate::isOpen));
    public final BooleanSetting s2CCloseScreen = this.add(new BooleanSetting("S2CCloseScreen", true));
    public final BooleanSetting s2CInventory = this.add(new BooleanSetting("S2CInventory", false).setParent());
    public final SliderSetting timeout = this.add(new SliderSetting("Timeout", 500, 0, 1000, this.s2CInventory::isOpen));
    public final BooleanSetting autoSync = this.add(new BooleanSetting("AutoSync", false, this.s2CInventory::isOpen).setParent());
    public final SliderSetting delay = this.add(new SliderSetting("Delay", 2000, 0, 5000, () -> this.s2CInventory.isOpen() && this.autoSync.isOpen()));
    private final Timer applyTimer = new Timer();
    private final Timer clickSlot = new Timer();
    private final Timer sync = new Timer();
    ClickSlotC2SPacket syncPacket;

    public AntiPacket() {
        super("AntiPacket", Module.Category.Exploit);
        this.setChinese("\u53cd\u6570\u636e\u5305");
        INSTANCE = this;
    }

    @EventListener
    public void onServerConnectBegin(ServerConnectBeginEvent event) {
        this.applyTimer.reset();
    }

    @Override
    public void onLogin() {
        this.applyTimer.reset();
    }

    @EventListener
    public void onCloseScreen(S2CCloseScreenEvent event) {
        if (this.s2CCloseScreen.getValue() && EntityUtil.inInventory()) {
            event.cancel();
        }
    }

    @EventListener
    public void onEvent(LerpToEvent event) {
        if (this.lerp.getValue()) {
            event.getEntity().setPos(event.getX(), event.getY(), event.getZ());
            event.getEntity().setPitch(event.getXRot());
            event.getEntity().setYaw(event.getYRot());
        }
    }

    @EventListener
    public void onPacketSend(PacketEvent.Send event) {
        ClickSlotC2SPacket clickSlotC2SPacket;
        Packet<?> packet = event.getPacket();
        if (packet instanceof ClickSlotC2SPacket && (clickSlotC2SPacket = (ClickSlotC2SPacket)packet) != this.syncPacket) {
            this.clickSlot.reset();
            this.sync.reset();
        }
    }

    @EventListener
    public void onTick(TickEvent event) {
        if (event.isPre() && this.s2CInventory.getValue() && !AntiPacket.mc.player.isCreative() && Sorter.INSTANCE.isOff() && this.autoSync.getValue() && this.clickSlot.passed(this.timeout.getValueInt()) && this.sync.passed(this.delay.getValueInt())) {
            this.syncPacket = new ClickSlotC2SPacket(AntiPacket.mc.player.playerScreenHandler.syncId, AntiPacket.mc.player.playerScreenHandler.getRevision(), -1, 0, SlotActionType.PICKUP, AntiPacket.mc.player.playerScreenHandler.getCursorStack().copy(), (Int2ObjectMap)new Int2ObjectArrayMap());
            mc.getNetworkHandler().sendPacket((Packet)this.syncPacket);
            this.sync.reset();
        }
    }

    @EventListener
    public void onInventory(InventoryS2CPacketEvent event) {
        InventoryS2CPacket packet = event.packet;
        if (this.s2CInventory.getValue() && Sorter.INSTANCE.isOff() && !AntiPacket.mc.player.isCreative()) {
            List packetContents = packet.getContents();
            boolean allowSync = this.clickSlot.passed(this.timeout.getValueInt());
            for (int i = 0; i < packetContents.size(); ++i) {
                ItemStack packetStack = (ItemStack)packetContents.get(i);
                Slot slot = AntiPacket.mc.player.playerScreenHandler.getSlot(i);
                ItemStack currentStack = slot.getStack();
                if (!allowSync && currentStack.getItem() != packetStack.getItem() && (!packetStack.isEmpty() || !currentStack.isStackable())) continue;
                slot.setStackNoCallbacks(packetStack);
            }
            if (allowSync) {
                AntiPacket.mc.player.playerScreenHandler.setCursorStack(packet.getCursorStack());
                ((dev.idhammai.asm.accessors.IScreenHandler)AntiPacket.mc.player.playerScreenHandler).setRevision(packet.getRevision());
                this.clickSlot.reset();
            }
            event.cancel();
        }
    }

    @EventListener
    public void onPacketReceive(PacketEvent.Receive event) {
        Packet<?> packet;
        if (!this.applyTimer.passed(1000L) || AntiPacket.nullCheck()) {
            return;
        }
        if (this.s2CSlot.getValue() && (packet = event.getPacket()) instanceof UpdateSelectedSlotS2CPacket) {
            UpdateSelectedSlotS2CPacket packet2 = (UpdateSelectedSlotS2CPacket)packet;
            event.setCancelled(true);
            Frog.SERVER.currentSlot = -1;
            mc.getNetworkHandler().sendPacket((Packet)new UpdateSelectedSlotC2SPacket(packet2.getSlot()));
            Frog.SERVER.currentSlot = -1;
            mc.getNetworkHandler().sendPacket((Packet)new UpdateSelectedSlotC2SPacket(AntiPacket.mc.player.getInventory().selectedSlot));
        } else if (this.s2CInventory.getValue() && event.getPacket() instanceof ScreenHandlerSlotUpdateS2CPacket && Sorter.INSTANCE.isOff() && !AntiPacket.mc.player.isCreative()) {
            event.cancel();
        }
    }
}

