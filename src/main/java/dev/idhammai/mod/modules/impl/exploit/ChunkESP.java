/*
 * Decompiled with CFR 0.152.
 * 
 * Could not load the following classes:
 *  net.minecraft.block.Block
 *  net.minecraft.block.BlockState
 *  net.minecraft.block.Blocks
 *  net.minecraft.client.gui.screen.DisconnectedScreen
 *  net.minecraft.client.gui.screen.DownloadingTerrainScreen
 *  net.minecraft.fluid.FluidState
 *  net.minecraft.nbt.NbtCompound
 *  net.minecraft.network.packet.Packet
 *  net.minecraft.network.packet.c2s.play.AcknowledgeChunksC2SPacket
 *  net.minecraft.network.packet.s2c.play.BlockUpdateS2CPacket
 *  net.minecraft.network.packet.s2c.play.ChunkDataS2CPacket
 *  net.minecraft.network.packet.s2c.play.ChunkDeltaUpdateS2CPacket
 *  net.minecraft.registry.entry.RegistryEntry
 *  net.minecraft.util.math.BlockPos
 *  net.minecraft.util.math.Box
 *  net.minecraft.util.math.ChunkPos
 *  net.minecraft.util.math.Direction
 *  net.minecraft.util.math.Vec3d
 *  net.minecraft.util.math.Vec3i
 *  net.minecraft.world.World
 *  net.minecraft.world.biome.BiomeKeys
 *  net.minecraft.world.chunk.BiMapPalette
 *  net.minecraft.world.chunk.ChunkSection
 *  net.minecraft.world.chunk.Palette
 *  net.minecraft.world.chunk.PalettedContainer
 *  net.minecraft.world.chunk.ReadableContainer
 *  net.minecraft.world.chunk.WorldChunk
 */
package dev.idhammai.mod.modules.impl.exploit;

import dev.idhammai.api.events.eventbus.EventListener;
import dev.idhammai.api.events.impl.GameLeftEvent;
import dev.idhammai.api.events.impl.OpenScreenEvent;
import dev.idhammai.api.events.impl.PacketEvent;
import dev.idhammai.api.events.impl.Render3DEvent;
import dev.idhammai.api.events.impl.UpdateEvent;
import dev.idhammai.mod.modules.Module;
import dev.idhammai.mod.modules.settings.impl.BooleanSetting;
import dev.idhammai.mod.modules.settings.impl.ColorSetting;
import dev.idhammai.mod.modules.settings.impl.EnumSetting;
import dev.idhammai.mod.modules.settings.impl.SliderSetting;
import java.awt.Color;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import net.minecraft.block.Block;
import net.minecraft.block.BlockState;
import net.minecraft.block.Blocks;
import net.minecraft.client.gui.screen.DisconnectedScreen;
import net.minecraft.client.gui.screen.DownloadingTerrainScreen;
import net.minecraft.fluid.FluidState;
import net.minecraft.nbt.NbtCompound;
import net.minecraft.network.packet.Packet;
import net.minecraft.network.packet.c2s.play.AcknowledgeChunksC2SPacket;
import net.minecraft.network.packet.s2c.play.BlockUpdateS2CPacket;
import net.minecraft.network.packet.s2c.play.ChunkDataS2CPacket;
import net.minecraft.network.packet.s2c.play.ChunkDeltaUpdateS2CPacket;
import net.minecraft.registry.entry.RegistryEntry;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Box;
import net.minecraft.util.math.ChunkPos;
import net.minecraft.util.math.Direction;
import net.minecraft.util.math.Vec3d;
import net.minecraft.util.math.Vec3i;
import net.minecraft.world.World;
import net.minecraft.world.biome.BiomeKeys;
import net.minecraft.world.chunk.BiMapPalette;
import net.minecraft.world.chunk.ChunkSection;
import net.minecraft.world.chunk.Palette;
import net.minecraft.world.chunk.PalettedContainer;
import net.minecraft.world.chunk.ReadableContainer;
import net.minecraft.world.chunk.WorldChunk;

public class ChunkESP
extends Module {
    private static final ExecutorService taskExecutor = Executors.newCachedThreadPool();
    private static final Direction[] searchDirs = new Direction[]{Direction.EAST, Direction.NORTH, Direction.WEST, Direction.SOUTH, Direction.UP};
    private static final Set<Block> ORE_BLOCKS = new HashSet<Block>();
    private static final Set<Block> NEW_OVERWORLD_BLOCKS = new HashSet<Block>();
    private static final Set<Block> NEW_NETHER_BLOCKS = new HashSet<Block>();
    public static int newchunksfound = 0;
    public static int oldchunksfound = 0;
    public static int beingUpdatedOldChunksfound = 0;
    public static int OldGenerationOldChunksfound = 0;
    public static int tickexploitchunksfound = 0;
    public final EnumSetting<DetectMode> detectmode = this.add(new EnumSetting<DetectMode>("DetectMode", DetectMode.Normal));
    public final SliderSetting renderDistance = this.add(new SliderSetting("Chunks-Distance", 128, 6, 1024));
    public final SliderSetting renderHeight = this.add(new SliderSetting("RenderHeight", 0, -112, 319));
    final Set<ChunkPos> newChunks = Collections.synchronizedSet(new HashSet());
    final Set<ChunkPos> oldChunks = Collections.synchronizedSet(new HashSet());
    final Set<ChunkPos> beingUpdatedOldChunks = Collections.synchronizedSet(new HashSet());
    final Set<ChunkPos> OldGenerationOldChunks = Collections.synchronizedSet(new HashSet());
    final Set<ChunkPos> tickexploitChunks = Collections.synchronizedSet(new HashSet());
    private final BooleanSetting PaletteExploit = this.add(new BooleanSetting("PaletteExploit", true));
    private final BooleanSetting beingUpdatedDetector = this.add(new BooleanSetting("BeingUpdated", true));
    private final BooleanSetting overworldOldChunksDetector = this.add(new BooleanSetting("OverworldOldChunks", true));
    private final BooleanSetting netherOldChunksDetector = this.add(new BooleanSetting("NetherOldChunks", true));
    private final BooleanSetting endOldChunksDetector = this.add(new BooleanSetting("EndOldChunks", true));
    private final BooleanSetting liquidexploit = this.add(new BooleanSetting("LiquidExploit", false));
    private final BooleanSetting blockupdateexploit = this.add(new BooleanSetting("blockUpdateExploit", false));
    private final BooleanSetting worldleaveremove = this.add(new BooleanSetting("WorldLeaveRemove", true));
    private final BooleanSetting removerenderdist = this.add(new BooleanSetting("RemoveRenderDist", false));
    private final ColorSetting newChunksSideColor = this.add(new ColorSetting("New", new Color(255, 0, 0, 95)));
    private final ColorSetting tickexploitChunksSideColor = this.add(new ColorSetting("BlockExploit", new Color(0, 0, 255, 75)));
    private final ColorSetting oldChunksSideColor = this.add(new ColorSetting("Old", new Color(0, 255, 0, 40)));
    private final ColorSetting beingUpdatedOldChunksSideColor = this.add(new ColorSetting("BeingUpdated", new Color(0, 255, 0, 40)));
    private final ColorSetting OldGenerationOldChunksSideColor = this.add(new ColorSetting("OldVersion", new Color(190, 255, 0, 40)));
    public int chunkcounterticks = 0;
    private int errticks = 0;

    public ChunkESP() {
        super("ChunkESP", Module.Category.Exploit);
        this.setChinese("\u533a\u5757\u663e\u793a");
    }

    private void resetCounterValues() {
        this.chunkcounterticks = 0;
        newchunksfound = 0;
        oldchunksfound = 0;
        beingUpdatedOldChunksfound = 0;
        OldGenerationOldChunksfound = 0;
        tickexploitchunksfound = 0;
    }

    private void clearChunkData() {
        this.newChunks.clear();
        this.oldChunks.clear();
        this.beingUpdatedOldChunks.clear();
        this.OldGenerationOldChunks.clear();
        this.tickexploitChunks.clear();
    }

    @Override
    public void onDisable() {
        this.chunkcounterticks = 0;
    }

    @EventListener
    private void onScreenOpen(OpenScreenEvent event) {
        if (event.screen instanceof DisconnectedScreen) {
            this.resetCounterValues();
            if (this.worldleaveremove.getValue()) {
                this.clearChunkData();
            }
        }
        if (event.screen instanceof DownloadingTerrainScreen) {
            this.resetCounterValues();
        }
    }

    @EventListener
    private void onGameLeft(GameLeftEvent event) {
        this.resetCounterValues();
        if (this.worldleaveremove.getValue()) {
            this.clearChunkData();
        }
    }

    @EventListener
    public void onUpdate(UpdateEvent event) {
        if (ChunkESP.mc.player.getHealth() == 0.0f) {
            this.resetCounterValues();
        }
        if (this.detectmode.getValue() == DetectMode.Normal && this.blockupdateexploit.getValue()) {
            if (this.errticks < 6) {
                ++this.errticks;
            }
            if (this.errticks == 5) {
                this.sendMessage("\u00a74BlockExploitMode RECOMMENDED. Required to determine false positives from the Block Exploit from the OldChunks.");
            }
        } else {
            this.errticks = 0;
        }
        if (this.removerenderdist.getValue()) {
            this.removeChunksOutsideRenderDistance();
        }
    }

    /*
     * WARNING - Removed try catching itself - possible behaviour change.
     */
    @EventListener
    private void onRender(Render3DEvent event) {
        Set<ChunkPos> set = this.newChunks;
        synchronized (set) {
            for (ChunkPos c : this.newChunks) {
                if (c == null || !mc.getCameraEntity().getBlockPos().isWithinDistance((Vec3i)c.getStartPos(), this.renderDistance.getValue() * 16.0)) continue;
                event.drawFill(new Box(new Vec3d((double)c.getStartPos().getX(), (double)c.getStartPos().getY() + this.renderHeight.getValue(), (double)c.getStartPos().getZ()), new Vec3d((double)(c.getStartPos().getX() + 16), (double)c.getStartPos().getY() + this.renderHeight.getValue(), (double)(c.getStartPos().getZ() + 16))), this.newChunksSideColor.getValue());
            }
        }
        set = this.tickexploitChunks;
        synchronized (set) {
            for (ChunkPos c : this.tickexploitChunks) {
                if (c == null || !mc.getCameraEntity().getBlockPos().isWithinDistance((Vec3i)c.getStartPos(), this.renderDistance.getValue() * 16.0)) continue;
                if (this.detectmode.getValue() == DetectMode.BlockExploitMode && this.blockupdateexploit.getValue()) {
                    event.drawFill(new Box(new Vec3d((double)c.getStartPos().getX(), (double)c.getStartPos().getY() + this.renderHeight.getValue(), (double)c.getStartPos().getZ()), new Vec3d((double)(c.getStartPos().getX() + 16), (double)c.getStartPos().getY() + this.renderHeight.getValue(), (double)(c.getStartPos().getZ() + 16))), this.tickexploitChunksSideColor.getValue());
                    continue;
                }
                if (this.detectmode.getValue() == DetectMode.Normal && this.blockupdateexploit.getValue()) {
                    event.drawFill(new Box(new Vec3d((double)c.getStartPos().getX(), (double)c.getStartPos().getY() + this.renderHeight.getValue(), (double)c.getStartPos().getZ()), new Vec3d((double)(c.getStartPos().getX() + 16), (double)c.getStartPos().getY() + this.renderHeight.getValue(), (double)(c.getStartPos().getZ() + 16))), this.newChunksSideColor.getValue());
                    continue;
                }
                if (this.detectmode.getValue() == DetectMode.IgnoreBlockExploit && this.blockupdateexploit.getValue()) {
                    event.drawFill(new Box(new Vec3d((double)c.getStartPos().getX(), (double)c.getStartPos().getY() + this.renderHeight.getValue(), (double)c.getStartPos().getZ()), new Vec3d((double)(c.getStartPos().getX() + 16), (double)c.getStartPos().getY() + this.renderHeight.getValue(), (double)(c.getStartPos().getZ() + 16))), this.oldChunksSideColor.getValue());
                    continue;
                }
                if (!(this.detectmode.getValue() == DetectMode.BlockExploitMode | this.detectmode.getValue() == DetectMode.Normal | this.detectmode.getValue() == DetectMode.IgnoreBlockExploit)) continue;
                event.drawFill(new Box(new Vec3d((double)c.getStartPos().getX(), (double)c.getStartPos().getY() + this.renderHeight.getValue(), (double)c.getStartPos().getZ()), new Vec3d((double)(c.getStartPos().getX() + 16), (double)c.getStartPos().getY() + this.renderHeight.getValue(), (double)(c.getStartPos().getZ() + 16))), this.oldChunksSideColor.getValue());
            }
        }
        set = this.oldChunks;
        synchronized (set) {
            for (ChunkPos c : this.oldChunks) {
                if (c == null || !mc.getCameraEntity().getBlockPos().isWithinDistance((Vec3i)c.getStartPos(), this.renderDistance.getValue() * 16.0)) continue;
                event.drawFill(new Box(new Vec3d((double)c.getStartPos().getX(), (double)c.getStartPos().getY() + this.renderHeight.getValue(), (double)c.getStartPos().getZ()), new Vec3d((double)(c.getStartPos().getX() + 16), (double)c.getStartPos().getY() + this.renderHeight.getValue(), (double)(c.getStartPos().getZ() + 16))), this.oldChunksSideColor.getValue());
            }
        }
        set = this.beingUpdatedOldChunks;
        synchronized (set) {
            for (ChunkPos c : this.beingUpdatedOldChunks) {
                if (c == null || !mc.getCameraEntity().getBlockPos().isWithinDistance((Vec3i)c.getStartPos(), this.renderDistance.getValue() * 16.0)) continue;
                event.drawFill(new Box(new Vec3d((double)c.getStartPos().getX(), (double)c.getStartPos().getY() + this.renderHeight.getValue(), (double)c.getStartPos().getZ()), new Vec3d((double)(c.getStartPos().getX() + 16), (double)c.getStartPos().getY() + this.renderHeight.getValue(), (double)(c.getStartPos().getZ() + 16))), this.beingUpdatedOldChunksSideColor.getValue());
            }
        }
        set = this.OldGenerationOldChunks;
        synchronized (set) {
            for (ChunkPos c : this.OldGenerationOldChunks) {
                if (c == null || !mc.getCameraEntity().getBlockPos().isWithinDistance((Vec3i)c.getStartPos(), this.renderDistance.getValue() * 16.0)) continue;
                event.drawFill(new Box(new Vec3d((double)c.getStartPos().getX(), (double)c.getStartPos().getY() + this.renderHeight.getValue(), (double)c.getStartPos().getZ()), new Vec3d((double)(c.getStartPos().getX() + 16), (double)c.getStartPos().getY() + this.renderHeight.getValue(), (double)(c.getStartPos().getZ() + 16))), this.OldGenerationOldChunksSideColor.getValue());
            }
        }
    }

    @EventListener
    private void onReadPacket(PacketEvent.Receive event) {
        block86: {
            ChunkPos chunkPos;
            block87: {
                Packet<?> packet;
                block85: {
                    if (event.getPacket() instanceof AcknowledgeChunksC2SPacket) {
                        return;
                    }
                    packet = event.getPacket();
                    if (!(packet instanceof ChunkDeltaUpdateS2CPacket)) break block85;
                    ChunkDeltaUpdateS2CPacket packet2 = (ChunkDeltaUpdateS2CPacket)packet;
                    if (!this.liquidexploit.getValue()) break block85;
                    packet2.visitUpdates((pos, state) -> {
                        ChunkPos updateChunkPos = new ChunkPos(pos);
                        if (!state.getFluidState().isEmpty() && !state.getFluidState().isStill()) {
                            for (Direction dir : searchDirs) {
                                try {
                                    if (!(!ChunkESP.mc.world.getBlockState(pos.offset(dir)).getFluidState().isStill() || this.OldGenerationOldChunks.contains(updateChunkPos) || this.beingUpdatedOldChunks.contains(updateChunkPos) || this.newChunks.contains(updateChunkPos) || this.oldChunks.contains(updateChunkPos))) {
                                        this.tickexploitChunks.remove(updateChunkPos);
                                        this.newChunks.add(updateChunkPos);
                                        return;
                                    }
                                }
                                catch (Exception e) {
                                    e.printStackTrace();
                                }
                            }
                        }
                    });
                    break block86;
                }
                if (!((packet = event.getPacket()) instanceof BlockUpdateS2CPacket)) break block87;
                BlockUpdateS2CPacket packet3 = (BlockUpdateS2CPacket)packet;
                chunkPos = new ChunkPos(packet3.getPos());
                if (this.blockupdateexploit.getValue()) {
                    try {
                        if (!(this.OldGenerationOldChunks.contains(chunkPos) || this.beingUpdatedOldChunks.contains(chunkPos) || this.tickexploitChunks.contains(chunkPos) || this.oldChunks.contains(chunkPos) || this.newChunks.contains(chunkPos))) {
                            this.tickexploitChunks.add(chunkPos);
                        }
                    }
                    catch (Exception e) {
                        e.printStackTrace();
                    }
                }
                if (packet3.getState().getFluidState().isEmpty() || packet3.getState().getFluidState().isStill() || !this.liquidexploit.getValue()) break block86;
                for (Direction dir : searchDirs) {
                    try {
                        if (!ChunkESP.mc.world.getBlockState(packet3.getPos().offset(dir)).getFluidState().isStill() || this.OldGenerationOldChunks.contains(chunkPos) || this.beingUpdatedOldChunks.contains(chunkPos) || this.newChunks.contains(chunkPos) || this.oldChunks.contains(chunkPos)) continue;
                        this.tickexploitChunks.remove(chunkPos);
                        this.newChunks.add(chunkPos);
                        return;
                    }
                    catch (Exception e) {
                        e.printStackTrace();
                    }
                }
                break block86;
            }
            if (event.getPacket() instanceof ChunkDataS2CPacket) {
                ChunkDataS2CPacket packet = (ChunkDataS2CPacket)event.getPacket();
                if (ChunkESP.mc.world != null) {
                    ChunkPos oldpos = new ChunkPos(packet.getChunkX(), packet.getChunkZ());
                    if (ChunkESP.mc.world.getChunkManager().getChunk(packet.getChunkX(), packet.getChunkZ()) == null) {
                        int i;
                        ChunkSection section;
                        ReadableContainer biomesContainer;
                        int z;
                        int y;
                        int x;
                        ChunkSection section2;
                        int i2;
                        WorldChunk chunk = new WorldChunk((World)ChunkESP.mc.world, oldpos);
                        try {
                            CompletableFuture<Void> future = CompletableFuture.runAsync(() -> chunk.loadFromPacket(packet.getChunkData().getSectionsDataBuf(), new NbtCompound(), packet.getChunkData().getBlockEntities(packet.getChunkX(), packet.getChunkZ())), taskExecutor);
                            future.join();
                        }
                        catch (CompletionException e) {
                            e.printStackTrace();
                        }
                        boolean isNewChunk = false;
                        boolean isOldGeneration = false;
                        boolean chunkIsBeingUpdated = false;
                        boolean foundAnyOre = false;
                        boolean isNewOverworldGeneration = false;
                        boolean isNewNetherGeneration = false;
                        ChunkSection[] sections = chunk.getSectionArray();
                        if (this.overworldOldChunksDetector.getValue() && ChunkESP.mc.world.getRegistryKey() == World.OVERWORLD) {
                            for (i2 = 0; i2 < 17; ++i2) {
                                section2 = sections[i2];
                                if (section2 == null || section2.isEmpty()) continue;
                                for (x = 0; x < 16; ++x) {
                                    block21: for (y = 0; y < 16; ++y) {
                                        for (z = 0; z < 16; ++z) {
                                            if (!foundAnyOre && ORE_BLOCKS.contains(section2.getBlockState(x, y, z).getBlock())) {
                                                foundAnyOre = true;
                                            }
                                            if (isNewOverworldGeneration || !NEW_OVERWORLD_BLOCKS.contains(section2.getBlockState(x, y, z).getBlock())) continue;
                                            isNewOverworldGeneration = true;
                                            continue block21;
                                        }
                                    }
                                }
                            }
                            if (foundAnyOre && !isNewOverworldGeneration) {
                                isOldGeneration = true;
                            }
                        }
                        if (this.netherOldChunksDetector.getValue() && ChunkESP.mc.world.getRegistryKey() == World.NETHER) {
                            for (i2 = 0; i2 < 8; ++i2) {
                                section2 = sections[i2];
                                if (section2 == null || section2.isEmpty()) continue;
                                for (x = 0; x < 16; ++x) {
                                    block25: for (y = 0; y < 16; ++y) {
                                        for (z = 0; z < 16; ++z) {
                                            if (isNewNetherGeneration || !NEW_NETHER_BLOCKS.contains(section2.getBlockState(x, y, z).getBlock())) continue;
                                            isNewNetherGeneration = true;
                                            continue block25;
                                        }
                                    }
                                }
                            }
                            if (!isOldGeneration && !isNewNetherGeneration) {
                                isOldGeneration = true;
                            }
                        }
                        if (this.endOldChunksDetector.getValue() && ChunkESP.mc.world.getRegistryKey() == World.END && (biomesContainer = (section = chunk.getSection(0)).getBiomeContainer()) instanceof PalettedContainer) {
                            PalettedContainer biomesPaletteContainer = (PalettedContainer)biomesContainer;
                            Palette biomePalette = biomesPaletteContainer.data.palette();
                            for (i = 0; i < biomePalette.getSize(); ++i) {
                                if (((RegistryEntry)biomePalette.get(i)).getKey().get() != BiomeKeys.THE_END) continue;
                                isOldGeneration = true;
                                break;
                            }
                        }
                        if (this.PaletteExploit.getValue()) {
                            boolean bewlian = true;
                            boolean firstchunkappearsnew;
                            block83: {
                                firstchunkappearsnew = false;
                                int loops = 0;
                                int newChunkQuantifier = 0;
                                int oldChunkQuantifier = 0;
                                try {
                                    for (i = 0; i < 8; ++i) {
                                        ReadableContainer biomesContainer2;
                                        ChunkSection section3 = sections[i];
                                        if (section3 == null) continue;
                                        int isNewSection = 0;
                                        int isBeingUpdatedSection = 0;
                                        if (!section3.isEmpty()) {
                                            PalettedContainer blockStatesContainer = section3.getBlockStateContainer();
                                            Palette blockStatePalette = blockStatesContainer.data.palette();
                                            int blockPaletteLength = blockStatePalette.getSize();
                                            if (blockStatePalette instanceof BiMapPalette) {
                                                HashSet<BlockState> bstates = new HashSet<BlockState>();
                                                for (int x2 = 0; x2 < 16; ++x2) {
                                                    for (int y2 = 0; y2 < 16; ++y2) {
                                                        for (int z2 = 0; z2 < 16; ++z2) {
                                                            bstates.add((BlockState)blockStatesContainer.get(x2, y2, z2));
                                                        }
                                                    }
                                                }
                                                int bstatesSize = bstates.size();
                                                if (bstatesSize <= 1) {
                                                    bstatesSize = blockPaletteLength;
                                                }
                                                if (bstatesSize < blockPaletteLength) {
                                                    isNewSection = 2;
                                                    ++newChunkQuantifier;
                                                }
                                            }
                                            for (int i22 = 0; i22 < blockPaletteLength; ++i22) {
                                                BlockState blockPaletteEntry = (BlockState)blockStatePalette.get(i22);
                                                if (i22 == 0 && loops == 0 && blockPaletteEntry.getBlock() == Blocks.AIR && ChunkESP.mc.world.getRegistryKey() != World.END) {
                                                    firstchunkappearsnew = true;
                                                }
                                                if (i22 == 0 && blockPaletteEntry.getBlock() == Blocks.AIR && ChunkESP.mc.world.getRegistryKey() != World.NETHER && ChunkESP.mc.world.getRegistryKey() != World.END) {
                                                    ++isNewSection;
                                                }
                                                if (i22 == 1 && (blockPaletteEntry.getBlock() == Blocks.WATER || blockPaletteEntry.getBlock() == Blocks.STONE || blockPaletteEntry.getBlock() == Blocks.GRASS_BLOCK || blockPaletteEntry.getBlock() == Blocks.SNOW_BLOCK) && ChunkESP.mc.world.getRegistryKey() != World.NETHER && ChunkESP.mc.world.getRegistryKey() != World.END) {
                                                    ++isNewSection;
                                                }
                                                if (i22 == 2 && (blockPaletteEntry.getBlock() == Blocks.SNOW_BLOCK || blockPaletteEntry.getBlock() == Blocks.DIRT || blockPaletteEntry.getBlock() == Blocks.POWDER_SNOW) && ChunkESP.mc.world.getRegistryKey() != World.NETHER && ChunkESP.mc.world.getRegistryKey() != World.END) {
                                                    ++isNewSection;
                                                }
                                                if (loops == 4 && blockPaletteEntry.getBlock() == Blocks.BEDROCK && ChunkESP.mc.world.getRegistryKey() != World.NETHER && ChunkESP.mc.world.getRegistryKey() != World.END && !chunkIsBeingUpdated && this.beingUpdatedDetector.getValue()) {
                                                    chunkIsBeingUpdated = true;
                                                }
                                                if (blockPaletteEntry.getBlock() != Blocks.AIR || ChunkESP.mc.world.getRegistryKey() != World.NETHER && ChunkESP.mc.world.getRegistryKey() != World.END) continue;
                                                ++isBeingUpdatedSection;
                                            }
                                            if (isBeingUpdatedSection >= 2) {
                                                ++oldChunkQuantifier;
                                            }
                                            if (isNewSection >= 2) {
                                                ++newChunkQuantifier;
                                            }
                                        }
                                        if (ChunkESP.mc.world.getRegistryKey() == World.END && (biomesContainer2 = section3.getBiomeContainer()) instanceof PalettedContainer) {
                                            PalettedContainer biomesPaletteContainer = (PalettedContainer)biomesContainer2;
                                            Palette biomePalette = biomesPaletteContainer.data.palette();
                                            for (int i3 = 0; i3 < biomePalette.getSize(); ++i3) {
                                                if (i3 == 0 && ((RegistryEntry)biomePalette.get(i3)).getKey().get() == BiomeKeys.PLAINS) {
                                                    isNewChunk = true;
                                                }
                                                if (isNewChunk || i3 != 0 || ((RegistryEntry)biomePalette.get(i3)).getKey().get() == BiomeKeys.THE_END) continue;
                                                isNewChunk = false;
                                            }
                                        }
                                        if (section3.isEmpty()) continue;
                                        ++loops;
                                    }
                                    if (loops > 0) {
                                        double percentage;
                                        if (this.beingUpdatedDetector.getValue() && (ChunkESP.mc.world.getRegistryKey() == World.NETHER || ChunkESP.mc.world.getRegistryKey() == World.END)) {
                                            double oldpercentage = (double)oldChunkQuantifier / (double)loops * 100.0;
                                            if (oldpercentage >= 25.0) {
                                                chunkIsBeingUpdated = true;
                                            }
                                        } else if (ChunkESP.mc.world.getRegistryKey() != World.NETHER && ChunkESP.mc.world.getRegistryKey() != World.END && (percentage = (double)newChunkQuantifier / (double)loops * 100.0) >= 65.0) {
                                            isNewChunk = true;
                                        }
                                    }
                                }
                                catch (Exception e) {
                                    double percentage;
                                    if (this.beingUpdatedDetector.getValue() && (ChunkESP.mc.world.getRegistryKey() == World.NETHER || ChunkESP.mc.world.getRegistryKey() == World.END)) {
                                        double oldpercentage = (double)oldChunkQuantifier / (double)loops * 100.0;
                                        if (oldpercentage >= 25.0) {
                                            chunkIsBeingUpdated = true;
                                        }
                                    }
                                    if (ChunkESP.mc.world.getRegistryKey() == World.NETHER || ChunkESP.mc.world.getRegistryKey() == World.END || !((percentage = (double)newChunkQuantifier / (double)loops * 100.0) >= 65.0)) break block83;
                                    isNewChunk = true;
                                }
                            }
                            if (firstchunkappearsnew) {
                                isNewChunk = true;
                            }
                            boolean bl = ChunkESP.mc.world.getRegistryKey() == World.END ? isNewChunk : (bewlian = !isOldGeneration);
                            if (isNewChunk && !chunkIsBeingUpdated && bewlian) {
                                try {
                                    if (!(this.OldGenerationOldChunks.contains(oldpos) || this.beingUpdatedOldChunks.contains(oldpos) || this.tickexploitChunks.contains(oldpos) || this.oldChunks.contains(oldpos) || this.newChunks.contains(oldpos))) {
                                        this.newChunks.add(oldpos);
                                        return;
                                    }
                                }
                                catch (Exception e) {
                                    e.printStackTrace();
                                }
                            } else if (!isNewChunk && !chunkIsBeingUpdated && isOldGeneration) {
                                try {
                                    if (!(this.OldGenerationOldChunks.contains(oldpos) || this.beingUpdatedOldChunks.contains(oldpos) || this.oldChunks.contains(oldpos) || this.tickexploitChunks.contains(oldpos) || this.newChunks.contains(oldpos))) {
                                        this.OldGenerationOldChunks.add(oldpos);
                                        return;
                                    }
                                }
                                catch (Exception e) {
                                    e.printStackTrace();
                                }
                            } else if (chunkIsBeingUpdated) {
                                try {
                                    if (!(this.OldGenerationOldChunks.contains(oldpos) || this.beingUpdatedOldChunks.contains(oldpos) || this.oldChunks.contains(oldpos) || this.tickexploitChunks.contains(oldpos) || this.newChunks.contains(oldpos))) {
                                        this.beingUpdatedOldChunks.add(oldpos);
                                        return;
                                    }
                                }
                                catch (Exception e) {
                                    e.printStackTrace();
                                }
                            } else if (!isNewChunk) {
                                try {
                                    if (!(this.OldGenerationOldChunks.contains(oldpos) || this.beingUpdatedOldChunks.contains(oldpos) || this.tickexploitChunks.contains(oldpos) || this.oldChunks.contains(oldpos) || this.newChunks.contains(oldpos))) {
                                        this.oldChunks.add(oldpos);
                                        return;
                                    }
                                }
                                catch (Exception e) {
                                    e.printStackTrace();
                                }
                            }
                        }
                        if (this.liquidexploit.getValue()) {
                            for (int x3 = 0; x3 < 16; ++x3) {
                                for (int y3 = ChunkESP.mc.world.getBottomY(); y3 < ChunkESP.mc.world.getTopY(); ++y3) {
                                    for (int z3 = 0; z3 < 16; ++z3) {
                                        FluidState fluid = chunk.getFluidState(x3, y3, z3);
                                        try {
                                            if (this.OldGenerationOldChunks.contains(oldpos) || this.beingUpdatedOldChunks.contains(oldpos) || this.oldChunks.contains(oldpos) || this.tickexploitChunks.contains(oldpos) || this.newChunks.contains(oldpos) || fluid.isEmpty() || fluid.isStill()) continue;
                                            this.oldChunks.add(oldpos);
                                            return;
                                        }
                                        catch (Exception e) {
                                            e.printStackTrace();
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    private void removeChunksOutsideRenderDistance() {
        BlockPos cameraPos = mc.getCameraEntity().getBlockPos();
        double renderDistanceBlocks = this.renderDistance.getValue() * 16.0;
        this.removeChunksOutsideRenderDistance(this.newChunks, cameraPos, renderDistanceBlocks);
        this.removeChunksOutsideRenderDistance(this.oldChunks, cameraPos, renderDistanceBlocks);
        this.removeChunksOutsideRenderDistance(this.beingUpdatedOldChunks, cameraPos, renderDistanceBlocks);
        this.removeChunksOutsideRenderDistance(this.OldGenerationOldChunks, cameraPos, renderDistanceBlocks);
        this.removeChunksOutsideRenderDistance(this.tickexploitChunks, cameraPos, renderDistanceBlocks);
    }

    private void removeChunksOutsideRenderDistance(Set<ChunkPos> chunkSet, BlockPos cameraPos, double renderDistanceBlocks) {
        chunkSet.removeIf(chunkPos -> !cameraPos.isWithinDistance((Vec3i)chunkPos.getStartPos(), renderDistanceBlocks));
    }

    static {
        ORE_BLOCKS.add(Blocks.COAL_ORE);
        ORE_BLOCKS.add(Blocks.DEEPSLATE_COAL_ORE);
        ORE_BLOCKS.add(Blocks.COPPER_ORE);
        ORE_BLOCKS.add(Blocks.DEEPSLATE_COPPER_ORE);
        ORE_BLOCKS.add(Blocks.IRON_ORE);
        ORE_BLOCKS.add(Blocks.DEEPSLATE_IRON_ORE);
        ORE_BLOCKS.add(Blocks.GOLD_ORE);
        ORE_BLOCKS.add(Blocks.DEEPSLATE_GOLD_ORE);
        ORE_BLOCKS.add(Blocks.LAPIS_ORE);
        ORE_BLOCKS.add(Blocks.DEEPSLATE_LAPIS_ORE);
        ORE_BLOCKS.add(Blocks.DIAMOND_ORE);
        ORE_BLOCKS.add(Blocks.DEEPSLATE_DIAMOND_ORE);
        ORE_BLOCKS.add(Blocks.REDSTONE_ORE);
        ORE_BLOCKS.add(Blocks.DEEPSLATE_REDSTONE_ORE);
        ORE_BLOCKS.add(Blocks.EMERALD_ORE);
        ORE_BLOCKS.add(Blocks.DEEPSLATE_EMERALD_ORE);
        NEW_OVERWORLD_BLOCKS.add(Blocks.DEEPSLATE);
        NEW_OVERWORLD_BLOCKS.add(Blocks.AMETHYST_BLOCK);
        NEW_OVERWORLD_BLOCKS.add(Blocks.BUDDING_AMETHYST);
        NEW_OVERWORLD_BLOCKS.add(Blocks.AZALEA);
        NEW_OVERWORLD_BLOCKS.add(Blocks.FLOWERING_AZALEA);
        NEW_OVERWORLD_BLOCKS.add(Blocks.BIG_DRIPLEAF);
        NEW_OVERWORLD_BLOCKS.add(Blocks.BIG_DRIPLEAF_STEM);
        NEW_OVERWORLD_BLOCKS.add(Blocks.SMALL_DRIPLEAF);
        NEW_OVERWORLD_BLOCKS.add(Blocks.CAVE_VINES);
        NEW_OVERWORLD_BLOCKS.add(Blocks.CAVE_VINES_PLANT);
        NEW_OVERWORLD_BLOCKS.add(Blocks.SPORE_BLOSSOM);
        NEW_OVERWORLD_BLOCKS.add(Blocks.COPPER_ORE);
        NEW_OVERWORLD_BLOCKS.add(Blocks.DEEPSLATE_COPPER_ORE);
        NEW_OVERWORLD_BLOCKS.add(Blocks.DEEPSLATE_IRON_ORE);
        NEW_OVERWORLD_BLOCKS.add(Blocks.DEEPSLATE_COAL_ORE);
        NEW_OVERWORLD_BLOCKS.add(Blocks.DEEPSLATE_REDSTONE_ORE);
        NEW_OVERWORLD_BLOCKS.add(Blocks.DEEPSLATE_EMERALD_ORE);
        NEW_OVERWORLD_BLOCKS.add(Blocks.DEEPSLATE_GOLD_ORE);
        NEW_OVERWORLD_BLOCKS.add(Blocks.DEEPSLATE_LAPIS_ORE);
        NEW_OVERWORLD_BLOCKS.add(Blocks.DEEPSLATE_DIAMOND_ORE);
        NEW_OVERWORLD_BLOCKS.add(Blocks.GLOW_LICHEN);
        NEW_OVERWORLD_BLOCKS.add(Blocks.RAW_COPPER_BLOCK);
        NEW_OVERWORLD_BLOCKS.add(Blocks.RAW_IRON_BLOCK);
        NEW_OVERWORLD_BLOCKS.add(Blocks.DRIPSTONE_BLOCK);
        NEW_OVERWORLD_BLOCKS.add(Blocks.MOSS_BLOCK);
        NEW_OVERWORLD_BLOCKS.add(Blocks.MOSS_CARPET);
        NEW_OVERWORLD_BLOCKS.add(Blocks.POINTED_DRIPSTONE);
        NEW_OVERWORLD_BLOCKS.add(Blocks.SMOOTH_BASALT);
        NEW_OVERWORLD_BLOCKS.add(Blocks.TUFF);
        NEW_OVERWORLD_BLOCKS.add(Blocks.CALCITE);
        NEW_OVERWORLD_BLOCKS.add(Blocks.HANGING_ROOTS);
        NEW_OVERWORLD_BLOCKS.add(Blocks.ROOTED_DIRT);
        NEW_OVERWORLD_BLOCKS.add(Blocks.AZALEA_LEAVES);
        NEW_OVERWORLD_BLOCKS.add(Blocks.FLOWERING_AZALEA_LEAVES);
        NEW_OVERWORLD_BLOCKS.add(Blocks.POWDER_SNOW);
        NEW_NETHER_BLOCKS.add(Blocks.ANCIENT_DEBRIS);
        NEW_NETHER_BLOCKS.add(Blocks.BASALT);
        NEW_NETHER_BLOCKS.add(Blocks.BLACKSTONE);
        NEW_NETHER_BLOCKS.add(Blocks.GILDED_BLACKSTONE);
        NEW_NETHER_BLOCKS.add(Blocks.POLISHED_BLACKSTONE_BRICKS);
        NEW_NETHER_BLOCKS.add(Blocks.CRIMSON_STEM);
        NEW_NETHER_BLOCKS.add(Blocks.CRIMSON_NYLIUM);
        NEW_NETHER_BLOCKS.add(Blocks.NETHER_GOLD_ORE);
        NEW_NETHER_BLOCKS.add(Blocks.WARPED_NYLIUM);
        NEW_NETHER_BLOCKS.add(Blocks.WARPED_STEM);
        NEW_NETHER_BLOCKS.add(Blocks.TWISTING_VINES);
        NEW_NETHER_BLOCKS.add(Blocks.WEEPING_VINES);
        NEW_NETHER_BLOCKS.add(Blocks.BONE_BLOCK);
        NEW_NETHER_BLOCKS.add(Blocks.CHAIN);
        NEW_NETHER_BLOCKS.add(Blocks.OBSIDIAN);
        NEW_NETHER_BLOCKS.add(Blocks.CRYING_OBSIDIAN);
        NEW_NETHER_BLOCKS.add(Blocks.SOUL_SOIL);
        NEW_NETHER_BLOCKS.add(Blocks.SOUL_FIRE);
    }

    public static enum DetectMode {
        Normal,
        IgnoreBlockExploit,
        BlockExploitMode;

    }
}

