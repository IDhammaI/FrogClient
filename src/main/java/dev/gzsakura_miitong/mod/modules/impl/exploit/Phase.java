/*
 * Decompiled with CFR 0.152.
 * 
 * Could not load the following classes:
 *  net.minecraft.block.LadderBlock
 *  net.minecraft.block.ScaffoldingBlock
 *  net.minecraft.entity.Entity
 *  net.minecraft.entity.decoration.EndCrystalEntity
 *  net.minecraft.entity.decoration.ItemFrameEntity
 *  net.minecraft.entity.decoration.painting.PaintingEntity
 *  net.minecraft.item.Items
 *  net.minecraft.network.packet.c2s.play.PlayerActionC2SPacket
 *  net.minecraft.network.packet.c2s.play.PlayerActionC2SPacket$Action
 *  net.minecraft.network.packet.c2s.play.PlayerInteractItemC2SPacket
 *  net.minecraft.util.Hand
 *  net.minecraft.util.math.BlockPos
 *  net.minecraft.util.math.Box
 *  net.minecraft.util.math.Direction
 *  net.minecraft.util.math.MathHelper
 *  net.minecraft.util.math.Vec3d
 */
package dev.gzsakura_miitong.mod.modules.impl.exploit;

import dev.gzsakura_miitong.Alien;
import dev.gzsakura_miitong.api.events.eventbus.EventListener;
import dev.gzsakura_miitong.api.events.impl.ClientTickEvent;
import dev.gzsakura_miitong.api.events.impl.RotationEvent;
import dev.gzsakura_miitong.api.utils.combat.CombatUtil;
import dev.gzsakura_miitong.api.utils.player.EntityUtil;
import dev.gzsakura_miitong.api.utils.player.InventoryUtil;
import dev.gzsakura_miitong.api.utils.world.BlockUtil;
import dev.gzsakura_miitong.core.impl.RotationManager;
import dev.gzsakura_miitong.mod.modules.Module;
import dev.gzsakura_miitong.mod.modules.impl.movement.ElytraFly;
import dev.gzsakura_miitong.mod.modules.impl.movement.Velocity;
import dev.gzsakura_miitong.mod.modules.impl.player.AutoPearl;
import dev.gzsakura_miitong.mod.modules.impl.player.PacketMine;
import dev.gzsakura_miitong.mod.modules.settings.enums.Timing;
import dev.gzsakura_miitong.mod.modules.settings.impl.BooleanSetting;
import dev.gzsakura_miitong.mod.modules.settings.impl.EnumSetting;
import dev.gzsakura_miitong.mod.modules.settings.impl.SliderSetting;
import net.minecraft.block.LadderBlock;
import net.minecraft.block.ScaffoldingBlock;
import net.minecraft.entity.Entity;
import net.minecraft.entity.decoration.EndCrystalEntity;
import net.minecraft.entity.decoration.ItemFrameEntity;
import net.minecraft.entity.decoration.painting.PaintingEntity;
import net.minecraft.item.Items;
import net.minecraft.network.packet.c2s.play.PlayerActionC2SPacket;
import net.minecraft.network.packet.c2s.play.PlayerInteractItemC2SPacket;
import net.minecraft.util.Hand;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Box;
import net.minecraft.util.math.Direction;
import net.minecraft.util.math.MathHelper;
import net.minecraft.util.math.Vec3d;

public class Phase
extends Module {
    public static Phase INSTANCE;
    private final EnumSetting<Mode> mode = this.add(new EnumSetting<Mode>("Mode", Mode.Pearl));
    public final BooleanSetting onEnable = this.add(new BooleanSetting("OnEnable", true));
    public final BooleanSetting onlyGround = this.add(new BooleanSetting("OnlyGround", true));
    private final BooleanSetting breakBlock = this.add(new BooleanSetting("Break", true).setParent());
    private final BooleanSetting scaffolding = this.add(new BooleanSetting("Scaffolding", true, this.breakBlock::isOpen));
    private final BooleanSetting packetMine = this.add(new BooleanSetting("PacketMine", false, this.breakBlock::isOpen));
    private final BooleanSetting crystal = this.add(new BooleanSetting("Crystal", true, this.breakBlock::isOpen));
    private final BooleanSetting itemFrame = this.add(new BooleanSetting("ItemFrame", true, this.breakBlock::isOpen));
    private final BooleanSetting paint = this.add(new BooleanSetting("Paint", true, this.breakBlock::isOpen));
    private final BooleanSetting rotate = this.add(new BooleanSetting("Rotate", true, this.breakBlock::isOpen));
    public final BooleanSetting correct = this.add(new BooleanSetting("Correct", true));
    public final BooleanSetting dynamicPitch = this.add(new BooleanSetting("DynamicPitch", true, this.correct::getValue).setParent());
    private final SliderSetting factor = this.add(new SliderSetting("Factor", 0.5, 0.0, 1.0, 0.01, () -> this.dynamicPitch.isOpen() && this.correct.getValue()));
    private final BooleanSetting onlyHard = this.add(new BooleanSetting("OnlyHard", false, () -> this.dynamicPitch.isOpen() && this.correct.getValue()));
    public final SliderSetting pitch = this.add(new SliderSetting("Pitch", 88, 0, 90, () -> !this.dynamicPitch.getValue() || !this.correct.getValue()));
    private final EnumSetting<Timing> timing = this.add(new EnumSetting<Timing>("Timing", Timing.All));
    private final BooleanSetting yawStep = this.add(new BooleanSetting("YawStep", false).setParent());
    private final BooleanSetting whenElytra = this.add(new BooleanSetting("FallFlying", true, this.yawStep::isOpen));
    private final SliderSetting steps = this.add(new SliderSetting("Steps", 0.05, 0.0, 1.0, 0.01, this.yawStep::isOpen));
    private final SliderSetting fov = this.add(new SliderSetting("Fov", 20.0, 0.0, 360.0, 0.1, this.yawStep::isOpen));
    private final SliderSetting priority = this.add(new SliderSetting("Priority", 100, 0, 100, this.yawStep::isOpen));
    private final BooleanSetting sync = this.add(new BooleanSetting("Sync", true, this.yawStep::isOpen));
    public Vec3d directionVec = null;
    Vec3d targetPos;

    public Phase() {
        super("Phase", Module.Category.Exploit);
        this.setChinese("\u73cd\u73e0\u7a7f\u5899");
        INSTANCE = this;
    }

    @EventListener
    public void onRotate(RotationEvent event) {
        if (this.directionVec != null) {
            event.setTarget(this.directionVec, this.steps.getValueFloat(), this.priority.getValueFloat());
        }
    }

    private boolean faceVector(Vec3d directionVec) {
        this.directionVec = directionVec;
        return Alien.ROTATION.inFov(directionVec, this.fov.getValueFloat());
    }

    private void updatePos() {
        this.targetPos = new Vec3d(Phase.mc.player.getX() + MathHelper.clamp((double)(this.roundToClosest(Phase.mc.player.getX(), Math.floor(Phase.mc.player.getX()) + 0.241, Math.floor(Phase.mc.player.getX()) + 0.759) - Phase.mc.player.getX()), (double)-0.2, (double)0.2), Phase.mc.player.getY() - 0.5, Phase.mc.player.getZ() + MathHelper.clamp((double)(this.roundToClosest(Phase.mc.player.getZ(), Math.floor(Phase.mc.player.getZ()) + 0.241, Math.floor(Phase.mc.player.getZ()) + 0.759) - Phase.mc.player.getZ()), (double)-0.2, (double)0.2));
    }

    @EventListener
    public void onTick(ClientTickEvent event) {
        if (Phase.nullCheck()) {
            return;
        }
        if (this.timing.is(Timing.Pre) && event.isPost() || this.timing.is(Timing.Post) && event.isPre()) {
            return;
        }
        if (AutoPearl.INSTANCE.inventory.getValue() && !EntityUtil.inInventory()) {
            return;
        }
        if (Blink.INSTANCE.isOn() && Blink.INSTANCE.pauseModule.getValue()) {
            return;
        }
        if (this.onlyGround.getValue() && !Phase.mc.player.isOnGround() && !(BlockUtil.getBlock(Phase.mc.player.getBlockPos()) instanceof LadderBlock)) {
            return;
        }
        if (this.breakBlock.getValue()) {
            if (this.scaffolding.getValue()) {
                BlockPos self = EntityUtil.getPlayerPos(true);
                BlockPos selfFace = self.up();
                if (BlockUtil.getBlock(self) instanceof ScaffoldingBlock) {
                    this.mineBlock(self);
                    return;
                }
                if (BlockUtil.getBlock(selfFace) instanceof ScaffoldingBlock) {
                    this.mineBlock(selfFace);
                    return;
                }
            }
            for (Entity entity : Alien.THREAD.getEntities()) {
                if (entity instanceof EndCrystalEntity && this.crystal.getValue()) {
                    if (entity.getY() >= Phase.mc.player.getY() || !entity.getBoundingBox().intersects(Phase.mc.player.getBoundingBox())) continue;
                    CombatUtil.attack(entity, this.rotate.getValue());
                    continue;
                }
                if (this.itemFrame.getValue() && entity instanceof ItemFrameEntity) {
                    ItemFrameEntity itemFrameEntity = (ItemFrameEntity)entity;
                    if (!entity.getBoundingBox().intersects(new Box(Phase.mc.player.getBlockPos()))) continue;
                    if (!itemFrameEntity.getHeldItemStack().isEmpty()) {
                        CombatUtil.attack(entity, this.rotate.getValue());
                    }
                    CombatUtil.attack(entity, this.rotate.getValue());
                    continue;
                }
                if (!this.paint.getValue() || !(entity instanceof PaintingEntity) || !entity.getBoundingBox().intersects(new Box(Phase.mc.player.getBlockPos()))) continue;
                CombatUtil.attack(entity, this.rotate.getValue());
            }
        }
        if (!this.shouldYawStep()) {
            Velocity.INSTANCE.pearlTimer.reset();
            AutoPearl.INSTANCE.throwPearl(this.getYaw(), this.getPitch());
        } else {
            this.updatePos();
            if (!this.faceVector(this.targetPos)) {
                return;
            }
            Velocity.INSTANCE.pearlTimer.reset();
            if (this.sync.getValue()) {
                AutoPearl.INSTANCE.throwPearl(this.getYaw(), this.getPitch());
            } else {
                this.throwPearl();
            }
        }
        this.disable();
    }

    private boolean shouldYawStep() {
        if (!this.whenElytra.getValue() && (Phase.mc.player.isFallFlying() || ElytraFly.INSTANCE.isOn() && ElytraFly.INSTANCE.isFallFlying())) {
            return false;
        }
        return this.yawStep.getValue() && !Velocity.INSTANCE.noRotation();
    }

    private void mineBlock(BlockPos pos) {
        Phase.sendSequencedPacket(id -> new PlayerActionC2SPacket(PlayerActionC2SPacket.Action.START_DESTROY_BLOCK, pos, Direction.UP, id));
        Phase.sendSequencedPacket(id -> new PlayerActionC2SPacket(PlayerActionC2SPacket.Action.STOP_DESTROY_BLOCK, pos, Direction.UP, id));
        if (this.packetMine.getValue()) {
            PacketMine.INSTANCE.mine(pos);
        }
    }

    private Vec3d targetPos() {
        int[] offsets;
        BlockPos bp = Phase.mc.player.getBlockPos();
        Vec3d playerPos = Phase.mc.player.getPos();
        Vec3d centerPos = Phase.mc.player.getBlockPos().toBottomCenterPos();
        float factorValue = this.factor.getValueFloat();
        Vec3d closestPos = centerPos;
        double minDistance = Double.MAX_VALUE;
        for (int x : offsets = new int[]{1, -1}) {
            for (int z : offsets) {
                Vec3d tempPos;
                double getDistance;
                if ((this.onlyHard.getValue() || Phase.mc.world.isAir(bp.add(x, 0, 0)) && Phase.mc.world.isAir(bp.add(0, 0, z)) && Phase.mc.world.isAir(bp.add(x, 0, z))) && !Alien.HOLE.isHard(bp.add(x, 0, 0)) && !Alien.HOLE.isHard(bp.add(0, 0, z)) && !Alien.HOLE.isHard(bp.add(x, 0, z)) || !((getDistance = (tempPos = centerPos.add((double)((float)x * factorValue), 0.0, (double)((float)z * factorValue))).distanceTo(playerPos)) < minDistance)) continue;
                minDistance = getDistance;
                closestPos = tempPos;
            }
        }
        return closestPos;
    }

    private float getYaw() {
        if (this.correct.getValue()) {
            Vec3d targetPos;
            if (this.dynamicPitch.getValue() && (targetPos = this.targetPos()) != null) {
                return RotationManager.getRotation(targetPos)[0];
            }
            return MathHelper.wrapDegrees((float)(RotationManager.getRotation(Phase.mc.player.getBlockPos().toCenterPos())[0] - 180.0f));
        }
        return Phase.mc.player.getYaw();
    }

    private float getPitch() {
        Vec3d targetPos;
        if (this.correct.getValue() && this.dynamicPitch.getValue() && (targetPos = this.targetPos()) != null) {
            return RotationManager.getRotation(targetPos)[1];
        }
        return this.pitch.getValueFloat();
    }

    public void throwPearl() {
        int pearl;
        AutoPearl.throwing = true;
        if (Phase.mc.player.getMainHandStack().getItem() == Items.ENDER_PEARL) {
            Phase.sendSequencedPacket(id -> new PlayerInteractItemC2SPacket(Hand.MAIN_HAND, id, Alien.ROTATION.getLastYaw(), Alien.ROTATION.getLastPitch()));
            EntityUtil.swingHand(Hand.MAIN_HAND, AutoPearl.INSTANCE.interactSwing.getValue());
        } else if (AutoPearl.INSTANCE.inventory.getValue() && (pearl = InventoryUtil.findItemInventorySlotFromZero(Items.ENDER_PEARL)) != -1) {
            InventoryUtil.inventorySwap(pearl, Phase.mc.player.getInventory().selectedSlot);
            Phase.sendSequencedPacket(id -> new PlayerInteractItemC2SPacket(Hand.MAIN_HAND, id, Alien.ROTATION.getLastYaw(), Alien.ROTATION.getLastPitch()));
            EntityUtil.swingHand(Hand.MAIN_HAND, AutoPearl.INSTANCE.interactSwing.getValue());
            InventoryUtil.inventorySwap(pearl, Phase.mc.player.getInventory().selectedSlot);
            EntityUtil.syncInventory();
        } else {
            pearl = InventoryUtil.findItem(Items.ENDER_PEARL);
            if (pearl != -1) {
                int old = Phase.mc.player.getInventory().selectedSlot;
                InventoryUtil.switchToSlot(pearl);
                Phase.sendSequencedPacket(id -> new PlayerInteractItemC2SPacket(Hand.MAIN_HAND, id, Alien.ROTATION.getLastYaw(), Alien.ROTATION.getLastPitch()));
                EntityUtil.swingHand(Hand.MAIN_HAND, AutoPearl.INSTANCE.interactSwing.getValue());
                InventoryUtil.switchToSlot(old);
            }
        }
        AutoPearl.throwing = false;
    }

    @Override
    public void onEnable() {
        if (Phase.nullCheck()) {
            this.disable();
            return;
        }
        if (AutoPearl.INSTANCE.inventory.getValue()) {
            if (InventoryUtil.findItemInventorySlotFromZero(Items.ENDER_PEARL) == -1) {
                this.disable();
                return;
            }
        } else if (InventoryUtil.findItem(Items.ENDER_PEARL) == -1) {
            this.disable();
            return;
        }
        if (!this.onEnable.getValue()) {
            return;
        }
        if (this.onlyGround.getValue() && !Phase.mc.player.isOnGround() && !(BlockUtil.getBlock(Phase.mc.player.getBlockPos()) instanceof LadderBlock)) {
            return;
        }
        if (this.breakBlock.getValue()) {
            if (this.scaffolding.getValue()) {
                BlockPos self = EntityUtil.getPlayerPos(true);
                BlockPos selfFace = self.up();
                if (BlockUtil.getBlock(self) instanceof ScaffoldingBlock) {
                    this.mineBlock(self);
                    return;
                }
                if (BlockUtil.getBlock(selfFace) instanceof ScaffoldingBlock) {
                    this.mineBlock(selfFace);
                    return;
                }
            }
            for (Entity entity : Alien.THREAD.getEntities()) {
                if (entity instanceof EndCrystalEntity && this.crystal.getValue()) {
                    if (entity.getY() >= Phase.mc.player.getY() || !entity.getBoundingBox().intersects(Phase.mc.player.getBoundingBox())) continue;
                    CombatUtil.attack(entity, this.rotate.getValue());
                    continue;
                }
                if (this.itemFrame.getValue() && entity instanceof ItemFrameEntity) {
                    ItemFrameEntity itemFrameEntity = (ItemFrameEntity)entity;
                    if (!entity.getBoundingBox().intersects(new Box(Phase.mc.player.getBlockPos()))) continue;
                    if (!itemFrameEntity.getHeldItemStack().isEmpty()) {
                        CombatUtil.attack(entity, this.rotate.getValue());
                    }
                    CombatUtil.attack(entity, this.rotate.getValue());
                    continue;
                }
                if (!this.paint.getValue() || !(entity instanceof PaintingEntity) || !entity.getBoundingBox().intersects(new Box(Phase.mc.player.getBlockPos()))) continue;
                CombatUtil.attack(entity, this.rotate.getValue());
            }
        }
        this.directionVec = null;
        this.updatePos();
        if (this.shouldYawStep()) {
            return;
        }
        if (AutoPearl.INSTANCE.inventory.getValue() && !EntityUtil.inInventory()) {
            return;
        }
        if (Blink.INSTANCE.isOn() && Blink.INSTANCE.pauseModule.getValue()) {
            return;
        }
        Velocity.INSTANCE.pearlTimer.reset();
        AutoPearl.INSTANCE.throwPearl(this.getYaw(), this.getPitch());
        this.disable();
    }

    private double roundToClosest(double num, double low, double high) {
        double d2 = high - num;
        double d1 = num - low;
        if (d2 > d1) {
            return low;
        }
        return high;
    }

    private static enum Mode {
        Pearl;

    }
}

